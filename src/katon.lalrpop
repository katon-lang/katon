use std::str::FromStr;
use crate::ast::{Expr, FnDecl, Op, Stmt, Type, NodeId};
use crate::errors::{Spanned, Span};

grammar;

// ===========================================
// 0. Types
// ===========================================

pub Type: Type = {
    "int" => Type::Int,
    "nat" => Type::Nat,
    "bool" => Type::Bool,
    "[" <n:Int> ";" <t:Type> "]" => Type::Array(n as usize, Box::new(t)),
};

// ===========================================
// 1. Expressions (Pratt Logic / Precedence)
// ===========================================

// Tier 1: Lowest precedence (Comparisons)

pub Expr: Spanned<Expr> = {
    <l:@L> <lhs:Expr> "&&" <rhs:Compare> <r:@R> =>
        Spanned::new(Expr::Binary(Box::new(lhs), Op::And, Box::new(rhs)), Span::new(l, r)),
    Compare,
};

Compare: Spanned<Expr> = {
    <l:@L> <lhs:Compare> "==" <rhs:Add> <r:@R> =>
        Spanned::new(Expr::Binary(Box::new(lhs), Op::Eq, Box::new(rhs)), Span::new(l, r)),
    <l:@L> <lhs:Compare> ">" <rhs:Add> <r:@R> =>
        Spanned::new(Expr::Binary(Box::new(lhs), Op::Gt, Box::new(rhs)), Span::new(l, r)),
    <l:@L> <lhs:Compare> "<" <rhs:Add> <r:@R> =>
        Spanned::new(Expr::Binary(Box::new(lhs), Op::Lt, Box::new(rhs)), Span::new(l, r)),
    <l:@L> <lhs:Compare> ">=" <rhs:Add> <r:@R> =>
        Spanned::new(Expr::Binary(Box::new(lhs), Op::Gte, Box::new(rhs)), Span::new(l, r)),
    <l:@L> <lhs:Compare> "<=" <rhs:Add> <r:@R> =>
        Spanned::new(Expr::Binary(Box::new(lhs), Op::Lte, Box::new(rhs)), Span::new(l, r)),
    Add,
};

Add: Spanned<Expr> = {
    <l:@L> <lhs:Add> "+" <rhs:Mul> <r:@R> =>
        Spanned::new(Expr::Binary(Box::new(lhs), Op::Add, Box::new(rhs)), Span::new(l, r)),
    <l:@L> <lhs:Add> "-" <rhs:Mul> <r:@R> =>
        Spanned::new(Expr::Binary(Box::new(lhs), Op::Sub, Box::new(rhs)), Span::new(l, r)),
    Mul,
};

Mul: Spanned<Expr> = {
    <l:@L> <lhs:Mul> "*" <rhs:Unary> <r:@R> =>
        Spanned::new(Expr::Binary(Box::new(lhs), Op::Mul, Box::new(rhs)), Span::new(l, r)),
    <l:@L> <lhs:Mul> "/" <rhs:Unary> <r:@R> =>
        Spanned::new(Expr::Binary(Box::new(lhs), Op::Div, Box::new(rhs)), Span::new(l, r)),
    Unary,
};

Unary: Spanned<Expr> = {
    <l:@L> "-" <u:Unary> <r:@R> => {
        let zero = Spanned::new(Expr::IntLit(0), Span::new(l, l));
        Spanned::new(Expr::Binary(Box::new(zero), Op::Sub, Box::new(u)), Span::new(l, r))
    },
    Postfix,
};

Postfix: Spanned<Expr> = {
    <l:@L> <base:Postfix> "[" <idx:Expr> "]" <r:@R> =>
        Spanned::new(Expr::Binary(Box::new(base), Op::Index, Box::new(idx)), Span::new(l, r)),
    
    <l:@L> <base:Postfix> "." "length" "(" ")" <r:@R> => {
        // We can map this to a special Variable or a new Expr variant
        // For now, let's map it to the "var_length" naming convention 
        // our VCGen already uses.
        if let Expr::Var(ref name, _) = base.node {
             Spanned::new(Expr::Var(format!("{}_length", name), None), Span::new(l, r))
        } else {
             // Handle complex expressions if needed, or just allow it on Vars
             panic!("length() only supported on variables currently")
        }
    },
    Atom,
};

Atom: Spanned<Expr> = {
    <l:@L> <i:Int> <r:@R> =>
        Spanned::new(Expr::IntLit(i), Span::new(l, r)),
    <l:@L> <id:Ident> <r:@R> =>
        Spanned::new(Expr::Var(id, None), Span::new(l, r)),
    <l:@L> <t:Type> "(" <e:Expr> ")" <r:@R> =>
        Spanned::new(Expr::Cast(t, Box::new(e)), Span::new(l, r)),
    <l:@L> "old" "(" <id:Ident> ")" <r:@R> =>
        Spanned::new(Expr::Old(id, None), Span::new(l, r)),
    "(" <e:Expr> ")" => e,
    "true" => Spanned::dummy(Expr::BoolLit(true)),
    "false" => Spanned::dummy(Expr::BoolLit(false)),
    <l:@L> "[" <elems:Comma<Expr>> "]" <r:@R> => 
        Spanned::new(Expr::ArrayLit(elems), Span::new(l, r)),
};

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => { v.push(e); v }
    }
};

// ===========================================
// 2. Statements
// ===========================================

pub Stmt: Spanned<Stmt> = {
    // Add a semicolon here to resolve the Shift/Reduce conflicts
    <l:@L> <s:StmtKind> ";" <r:@R> => Spanned::new(s, Span::new(l, r)),
    
    // Control flow doesn't usually need semicolons after the closing brace
    <l:@L> <s:ControlFlow> <r:@R> => Spanned::new(s, Span::new(l, r)),
};

StmtKind: Stmt = {
    // 1. let x = 5; (Inferred/Immediate)
    "let" <id:Ident> "=" <e:Expr> => Stmt::Let {
        name: id,
        ty: None,
        value: Some(e),
        id: None,
    },


    // 2. let x: int; (Declaration only)
    "let" <id:Ident> ":" <t:Type> => Stmt::Let {
        name: id,
        ty: Some(t),
        value: None,
        id: None,
    },

    "let" <id:Ident> ":" <t:Type> "=" <e:Expr> => Stmt::Let {
        name: id,
        ty: Some(t),
        value: Some(e),
        id: None,
    },

    // ONLY define this once. The target_id must be None at parse time.
    <id:Ident> "=" <e:Expr> => Stmt::Assign { 
        target: id, 
        target_id: None, 
        value: e 
    },

    <id:Ident> "[" <idx:Expr> "]" "=" <val:Expr> => Stmt::ArrayUpdate { 
        target: id, 
        target_id: None,
        index: idx, 
        value: val 
    },
};

ControlFlow: Stmt = {
    "if" <cond:Expr> <then_block:Block> <else_block:("else" <Block>)?> => {
        Stmt::If {
            cond,
            then_block,
            else_block: else_block.unwrap_or(vec![]),
        }
    },
    "while" <cond:Expr> <invs:("invariant" <Expr>)*> <body:Block> => {
        // We transform the list of invariants into a single boolean AND expression
        // so we don't have to change our AST structure.
        let combined_invariant = invs.into_iter().reduce(|acc, e| {
            let l = e.span.start;
            let r = e.span.end;
            Spanned::new(
                Expr::Binary(Box::new(acc), Op::And, Box::new(e)),
                Span::new(l, r)
            )
        }).expect("At least one invariant is required by the verifier");

        Stmt::While {
            cond,
            invariant: combined_invariant,
            body,
        }
    },
};

// Block now returns Vec<Spanned<Stmt>> automatically 
// because Stmt returns Spanned<Stmt>
Block: Vec<Spanned<Stmt>> = {
    "{" <s:Stmt*> "}" => s
};

// ===========================================
// 3. Function Declaration
// ===========================================

// Requires and Ensures now expect Spanned<Expr> because 'Expr' rule returns it
Requires: Spanned<Expr> = {
    "requires" <e:Expr> ";" => e
};

Ensures: Spanned<Expr> = {
    <l:@L> "ensures" <e:Expr> ";" <r:@R> =>
        Spanned::new(e.node, Span::new(l, r))
};


Param: (String, Type) = {
    <id:Ident> ":" <t:Type> => (id, t)
};

Params: Vec<(String, Type)> = {
    <mut v:(<Param> ",")*> <e:Param?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

pub FnDecl: Spanned<FnDecl> = {
    <l:@L> "func" <name:Ident> "(" <ps:Params> ")" "{" 
        <req:Requires*>
        <body:Stmt*>
        <ens:Ensures*>
    "}" <r:@R> => {
        let mut params = Vec::new();
        let mut param_names = Vec::new();
        
        for (p_name, ty) in ps {
            params.push((NodeId(0), ty)); 
            param_names.push(p_name);
        }

        let node = FnDecl {
            name,
            params,
            span: Span::new(l, r), 
            param_names,
            requires: req,
            ensures: ens,
            body,
        };
        
        Spanned::new(node, Span::new(l, r))
    }
};

// ===========================================
// 4. Lexer / Terminals
// ===========================================

Int: i64 = <s:r"[0-9]+"> => i64::from_str(s).unwrap();
Ident: String = <s:r"[a-zA-Z_][a-zA-Z0-9_]*"> => s.to_string();

match {
    r"\s*" => { },
    r"//[^\n\r]*[\n\r]*" => { },
} else {
    _
}