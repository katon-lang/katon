use std::str::FromStr;
use crate::ast::{Expr, FnDecl, Op, Stmt, Type, NodeId};
use crate::errors::{Spanned, Span};

grammar;

// ===========================================
// 0. Types
// ===========================================

pub Type: Type = {
    "int" => Type::Int,
    "nat" => Type::Nat,
    "[" "]" <t:Type> => Type::Array(Box::new(t)),
};

// ===========================================
// 1. Expressions (Pratt Logic / Precedence)
// ===========================================

// Tier 1: Lowest precedence (Comparisons)
pub Expr: Spanned<Expr> = {
    <l:@L> <lhs:Expr> "==" <rhs:Term> <r:@R> => Spanned::new(Expr::Binary(Box::new(lhs), Op::Eq, Box::new(rhs)), Span::new(l, r)),
    <l:@L> <lhs:Expr> ">"  <rhs:Term> <r:@R> => Spanned::new(Expr::Binary(Box::new(lhs), Op::Gt, Box::new(rhs)), Span::new(l, r)),
    <l:@L> <lhs:Expr> "<"  <rhs:Term> <r:@R> => Spanned::new(Expr::Binary(Box::new(lhs), Op::Lt, Box::new(rhs)), Span::new(l, r)),
    <l:@L> <lhs:Expr> ">=" <rhs:Term> <r:@R> => Spanned::new(Expr::Binary(Box::new(lhs), Op::Gte, Box::new(rhs)), Span::new(l, r)),
    <l:@L> <lhs:Expr> "<=" <rhs:Term> <r:@R> => Spanned::new(Expr::Binary(Box::new(lhs), Op::Lte, Box::new(rhs)), Span::new(l, r)),
    Term,
};

// Tier 2: Arithmetic (+, -)
pub Term: Spanned<Expr> = {
    <l:@L> <lhs:Term> "+" <rhs:Product> <r:@R> => Spanned::new(Expr::Binary(Box::new(lhs), Op::Add, Box::new(rhs)), Span::new(l, r)),
    <l:@L> <lhs:Term> "-" <rhs:Product> <r:@R> => Spanned::new(Expr::Binary(Box::new(lhs), Op::Sub, Box::new(rhs)), Span::new(l, r)),
    Product,
};

pub Product: Spanned<Expr> = {
    <l:@L> <lhs:Product> "*" <rhs:Unary> <r:@R> => Spanned::new(Expr::Binary(Box::new(lhs), Op::Mul, Box::new(rhs)), Span::new(l, r)),
    <l:@L> <lhs:Product> "/" <rhs:Unary> <r:@R> => Spanned::new(Expr::Binary(Box::new(lhs), Op::Div, Box::new(rhs)), Span::new(l, r)),
    Unary,
};

pub Unary: Spanned<Expr> = {
    <l:@L> "-" <u:Unary> <r:@R> => {
        // Create a dummy 0 for the negation: 0 - u
        let zero = Spanned::new(Expr::IntLit(0), Span::new(l, l)); 
        Spanned::new(Expr::Binary(Box::new(zero), Op::Sub, Box::new(u)), Span::new(l, r))
    },
    Factor,
}

// Tier 3: Highest precedence (Atoms)
pub Factor: Spanned<Expr> = {
    <l:@L> <base:Factor> "[" <idx:Expr> "]" <r:@R> => Spanned::new(Expr::Binary(Box::new(base), Op::Index, Box::new(idx)), Span::new(l, r)),
    Atom,
};

pub Atom: Spanned<Expr> = {
    <l:@L> <i:Int> <r:@R> => Spanned::new(Expr::IntLit(i), Span::new(l, r)),
    <l:@L> <id:Ident> <r:@R> => Spanned::new(Expr::Var(id, None), Span::new(l, r)),
    <l:@L> <t:Type> "(" <e:Expr> ")" <r:@R> => Spanned::new(Expr::Cast(t, Box::new(e)), Span::new(l, r)),
    <l:@L> "old" "(" <id:Ident> ")" <r:@R> => Spanned::new(Expr::Old(id, None), Span::new(l, r)),
    "(" <e:Expr> ")" => e,
};

// ===========================================
// 2. Statements
// ===========================================

pub Stmt: Spanned<Stmt> = {
    // Add a semicolon here to resolve the Shift/Reduce conflicts
    <l:@L> <s:StmtKind> ";" <r:@R> => Spanned::new(s, Span::new(l, r)),
    
    // Control flow doesn't usually need semicolons after the closing brace
    <l:@L> <s:ControlFlow> <r:@R> => Spanned::new(s, Span::new(l, r)),
};

StmtKind: Stmt = {
    // ONLY define this once. The target_id must be None at parse time.
    <id:Ident> "=" <e:Expr> => Stmt::Assign { 
        target: id, 
        target_id: None, 
        value: e 
    },

    <id:Ident> "[" <idx:Expr> "]" "=" <val:Expr> => Stmt::ArrayUpdate { 
        target: id, 
        target_id: None,
        index: idx, 
        value: val 
    },
};

ControlFlow: Stmt = {
    "if" <cond:Expr> <then_block:Block> <else_block:("else" <Block>)?> => {
        Stmt::If {
            cond,
            then_block,
            else_block: else_block.unwrap_or(vec![]),
        }
    },
    "while" <cond:Expr> "invariant" <inv:Expr> <body:Block> => {
        Stmt::While {
            cond,
            invariant: inv,
            body,
        }
    },
};

// Block now returns Vec<Spanned<Stmt>> automatically 
// because Stmt returns Spanned<Stmt>
Block: Vec<Spanned<Stmt>> = {
    "{" <s:Stmt*> "}" => s
};

// ===========================================
// 3. Function Declaration
// ===========================================

// Requires and Ensures now expect Spanned<Expr> because 'Expr' rule returns it
Requires: Spanned<Expr> = {
    <l:@L> "requires" <e:Expr> ";" <r:@R> =>
        Spanned::new(e.node, Span::new(l, r))
};

Ensures: Spanned<Expr> = {
    <l:@L> "ensures" <e:Expr> ";" <r:@R> =>
        Spanned::new(e.node, Span::new(l, r))
};


Param: (String, Type) = {
    <id:Ident> ":" <t:Type> => (id, t)
};

Params: Vec<(String, Type)> = {
    <mut v:(<Param> ",")*> <e:Param?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

pub FnDecl: FnDecl = {
    "func" <name:Ident> "(" <ps:Params> ")" "{" 
        <req:Requires*>
        <body:Stmt*>
        <ens:Ensures*>
    "}" => {
        let mut params = Vec::new();
        let mut param_names = Vec::new();
        
        for (p_name, ty) in ps {
            params.push((NodeId(0), ty)); 
            param_names.push(p_name);
        }

        FnDecl {
            name,
            params,
            param_names,
            requires: req,
            ensures: ens,
            body,
        }
    }
};

// ===========================================
// 4. Lexer / Terminals
// ===========================================

Int: i64 = <s:r"[0-9]+"> => i64::from_str(s).unwrap();
Ident: String = <s:r"[a-zA-Z_][a-zA-Z0-9_]*"> => s.to_string();

match {
    r"\s*" => { },
    r"//[^\n\r]*[\n\r]*" => { },
} else {
    _
}